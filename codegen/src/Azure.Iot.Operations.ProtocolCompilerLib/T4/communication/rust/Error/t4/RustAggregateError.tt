<#@ template language="C#" linePragmas="false" #>
<#@ import namespace="Azure.Iot.Operations.ProtocolCompilerLib" #>
/* Code generated by Azure.Iot.Operations.ProtocolCompilerLib v<#=System.Reflection.Assembly.GetExecutingAssembly().GetName().Version#>; DO NOT EDIT. */

use std::error::Error;
use std::fmt;

use super::<#=this.schemaName.GetFileName(TargetLanguage.Rust)#>::<#=this.schemaName.GetTypeName(TargetLanguage.Rust)#>;

impl fmt::Display for <#=this.schemaName.GetTypeName(TargetLanguage.Rust)#> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut err_count = 0;

<# foreach (var innerNameSchema in this.innerNameSchemas) { #>

        if let Some(<#=innerNameSchema.Item1.GetFieldName(TargetLanguage.Rust)#>) = &self.<#=innerNameSchema.Item1.GetFieldName(TargetLanguage.Rust)#> {
            if err_count == 0 {
                return write!(f, "{<#=innerNameSchema.Item1.GetFieldName(TargetLanguage.Rust)#>}");
            }
            err_count += 1;
        }
<# } #>

        // Error display message depends on how many specific errors are reported within the aggregate error.
        // If there are none, the aggregate error must have been caused by one or more non-reportable errors.
        // If there is exactly one, it has already been displayed.
        // If there are two or more, only the first reported error has been displayed, so indicate how many more there are.
        match err_count{
            0 => write!(f, "No reportable property errors."),
            1 => Ok(()),
            2 => write!(f, "(And 1 more reported error.)"),
            _ => write!(f, "(And {} more reported errors.)", err_count - 1),
        }
    }
}

impl Error for <#=this.schemaName.GetTypeName(TargetLanguage.Rust)#> {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        None
    }
}

<#@ template language="C#" linePragmas="false" #>
<#@ import namespace="Azure.Iot.Operations.ProtocolCompiler" #>
/* Code generated by Azure.Iot.Operations.ProtocolCompiler v<#=System.Reflection.Assembly.GetExecutingAssembly().GetName().Version#>; DO NOT EDIT. */
#![allow(non_camel_case_types)]

<# if (this.stdHeaders.Any()) { #>
<# foreach (string header in this.stdHeaders) { #>
<#=header#>
<# } #>

<# } #>
<# if (this.extHeaders.Any()) { #>
use azure_iot_operations_protocol::common::payload_serialize::{
    FormatIndicator, PayloadError, PayloadSerialize, SerializedPayload,
};
<# foreach (string header in this.extHeaders) { #>
<#=header#>
<# } #>

<# } #>
use super::<#=this.schemaModuleName#>::<#=this.schemaClassName#>;

impl PayloadSerialize for <#=this.schemaClassName#> {
<# if (this.serdeLib != null) { #>
    type Error = <#=this.serdeLib#>::Error;

<# } #>

    fn serialize(self) -> Result<SerializedPayload, Self::Error> {
let payload = <# foreach (string serializeLine in this.serializeCode) { #>
        <#=serializeLine#>
<# } #>;
        Ok(SerializedPayload {
            payload: payload?,
            content_type: "<#=this.contentType#>",
            format_indicator: FormatIndicator::<#=this.formatIndicator#>,
        })
    }

    fn deserialize(payload: &[u8],
        content_type: &Option<String>,
        _format_indicator: &FormatIndicator,
    ) -> Result<Self, PayloadError<Self::Error>> {
        if let Some(content_type) = content_type {
            if content_type != "<#=this.contentType#>" {
                return Err(PayloadError::UnsupportedContentType(format!(
                    "Invalid content type: '{content_type}'. Must be '<#=this.contentType#>'"
                )));
            }
        }
<# foreach (string deserializeLine in this.deserializeCode) { #>
        <#=deserializeLine#>
<# } #>.map_err(PayloadError::DeserializationError)
    }
}
<# if (this.schemaCode != null) { #>

<#=this.schemaCode#>

const RAW_SCHEMA: &str = r#"
<#=this.schemaText#>
"#;
<# } #>

<#@ template language="C#" linePragmas="false" #>
// Code generated by Azure.Iot.Operations.ProtocolCompiler v<#=System.Reflection.Assembly.GetExecutingAssembly().GetName().Version#>; DO NOT EDIT.
package <#=this.genNamespace.GetFolderName(TargetLanguage.Go)#>

import (
	"context"

	"github.com/Azure/iot-operations-sdks/go/protocol"
<# if (this.errorResultName != null && !this.isRespNullable) { #>
	"github.com/Azure/iot-operations-sdks/go/protocol/errors"
<# } #>
)

type <#=this.commandName.GetTypeName(TargetLanguage.Go, "command", "invoker")#> struct {
	*protocol.CommandInvoker[<#=this.AsSchema(this.reqSchema)#>, <#=this.AsSchema(this.respSchema)#>]
}

func <#=this.commandName.GetMethodName(TargetLanguage.Go, "command", "invoker", prefix: "new")#>(
	app *protocol.Application,
	client protocol.MqttClient,
	requestTopic string,
	opt ...protocol.CommandInvokerOption,
) (*<#=this.commandName.GetTypeName(TargetLanguage.Go, "command", "invoker")#>, error) {
	var err error
	invoker := &<#=this.commandName.GetTypeName(TargetLanguage.Go, "command", "invoker")#>{}

	var opts protocol.CommandInvokerOptions
	opts.Apply(
		opt,
		protocol.WithTopicTokens{
			"commandName": "<#=this.commandName.AsGiven#>",
		},
	)

	invoker.CommandInvoker, err = protocol.NewCommandInvoker(
		app,
		client,
		protocol.<#=GetSerializer(this.reqSchema)#>{},
		protocol.<#=GetSerializer(this.respSchema)#>{},
		requestTopic,
		&opts,
	)

	return invoker, err
}

func (invoker <#=this.commandName.GetTypeName(TargetLanguage.Go, "command", "invoker")#>) <#=this.commandName.GetMethodName(TargetLanguage.Go)#>(
	ctx context.Context,
<# if (this.doesCommandTargetExecutor) { #>
	executorId string,
<# } #>
<# if (this.reqSchema != null) { #>
	request <#=this.AsSchema(this.reqSchema)#>,
<# } #>
	opt ...protocol.InvokeOption,
<# if (this.respSchema != null) { #>
) (*protocol.CommandResponse[<#=this.AsSchema(this.normalResultSchema ?? this.respSchema)#>], error) {
<# } else { #>
) error {
<# } #>
	invokerOpts := []protocol.InvokeOption{
		protocol.WithTopicTokenNamespace("ex:"),
<# if (this.doesCommandTargetExecutor) { #>
		protocol.WithTopicTokens{
			"executorId": executorId,
		},
<# } #>
	}

	var invokeOpts protocol.InvokeOptions
	invokeOpts.Apply(opt, invokerOpts...)

	<#=this.respSchema != null ? "response" : "_"#>, err := invoker.Invoke(
		ctx,
		<#=this.reqSchema != null ? "request" : "nil"#>,
		&invokeOpts,
	)

<# if (this.errorResultName != null) { #>
	if err != nil {
		return nil, err
	}

	if response.Payload.<#=this.errorResultName.GetFieldName(TargetLanguage.Go)#> != nil {
		return nil, response.Payload.<#=this.errorResultName.GetFieldName(TargetLanguage.Go)#>
	}

<# if (!this.isRespNullable) { #>
	if response.Payload.<#=this.normalResultName.GetFieldName(TargetLanguage.Go)#> == nil {
		return nil, &errors.Client{
			Message: "Command response has neither normal nor error payload content",
			Kind:    errors.PayloadInvalid{},
			Shallow: false,
		}
	}

<# } #>
	mappedResponse := protocol.CommandResponse[<#=this.normalResultSchema.GetTypeName(TargetLanguage.Go)#>]{
		protocol.Message[<#=this.normalResultSchema.GetTypeName(TargetLanguage.Go)#>]{
			Payload: <#=this.normalResultSchema.GetTypeName(TargetLanguage.Go)#>{
				<#=this.normalResultName.GetFieldName(TargetLanguage.Go)#>: <#=this.isRespNullable ? "" : "*"#>response.Payload.<#=this.normalResultName.GetFieldName(TargetLanguage.Go)#>,
			},
			ClientID:        response.ClientID,
			CorrelationData: response.CorrelationData,
			Timestamp:       response.Timestamp,
			TopicTokens:     response.TopicTokens,
			Metadata:        response.Metadata,
		},
	}

	return &mappedResponse, nil
<# } else { #>
	return <#=this.respSchema != null ? "response, " : ""#>err
<# } #>
}
<#+
    private string AsSchema(ITypeName schema) => schema == null ? "any" : schema.GetTypeName(TargetLanguage.Go);

    private string GetSerializer(ITypeName schema) => schema == null ? "Empty" : schema is RawTypeName ? "Raw" : $"{this.serializerSubNamespace}[{schema.GetTypeName(TargetLanguage.Go)}]";
#>

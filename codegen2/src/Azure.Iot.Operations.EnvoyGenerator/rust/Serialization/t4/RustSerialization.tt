<#@ template language="C#" linePragmas="false" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Azure.Iot.Operations.CodeGeneration" #>
/* Code generated by Azure.Iot.Operations.ProtocolCompilerLib v<#=System.Reflection.Assembly.GetExecutingAssembly().GetName().Version#>; DO NOT EDIT. */

<# if (this.stdHeaders.Any()) { #>
<# foreach (string header in this.stdHeaders) { #>
<#=header#>
<# } #>

<# } #>
<# if (this.extHeaders.Any()) { #>
use azure_iot_operations_protocol::common::payload_serialize::{
    DeserializationError, FormatIndicator, PayloadSerialize, SerializedPayload,
};
<# foreach (string header in this.extHeaders) { #>
<#=header#>
<# } #>

<# } #>
use super::<#=this.schemaClassName.GetFileName(TargetLanguage.Rust)#>::<#=this.schemaClassName.GetTypeName(TargetLanguage.Rust)#>;

<#
    var contentTypeConstName = this.schemaClassName.GetConstantName(TargetLanguage.Rust, "content", "type");
#>
const <#=contentTypeConstName#>: &str = "<#=this.contentType#>";

impl <#=this.schemaClassName.GetTypeName(TargetLanguage.Rust)#> {
    fn is_content_type(content_type: &str) -> bool {
        content_type.starts_with(<#=contentTypeConstName#>)
            && matches!(
                content_type
                    .chars()
                    .nth(<#=contentTypeConstName#>.len()),
                None | Some('+' | ';')
            )
    }
}

impl PayloadSerialize for <#=this.schemaClassName.GetTypeName(TargetLanguage.Rust)#> {
<# if (this.serdeLib != null) { #>
    type Error = <#=this.serdeLib#>::Error;

<# } #>
    fn serialize(self) -> Result<SerializedPayload, Self::Error> {
        let payload = <#=this.serializeCode.First()#><#=this.serializeCode.Count == 1 ? ";" : ""#>
<# int ix = 2; foreach (string serializeLine in this.serializeCode.Skip(1)) { #>
        <#=serializeLine#><#=ix == this.serializeCode.Count ? ";" : ""#>
<# ix++; } #>
        Ok(SerializedPayload {
            payload: payload?,
            content_type: "<#=this.contentType#>".to_string(),
            format_indicator: FormatIndicator::<#=this.formatIndicator#>,
        })
    }

    fn deserialize(
        payload: &[u8],
        content_type: Option<&String>,
        _format_indicator: &FormatIndicator,
    ) -> Result<Self, DeserializationError<Self::Error>> {
        if let Some(content_type) = content_type
            && !<#=this.schemaClassName.GetTypeName(TargetLanguage.Rust)#>::is_content_type(content_type)
        {
            return Err(DeserializationError::UnsupportedContentType(format!(
                "Invalid content type: '{content_type}'. Must be '<#=this.contentType#>'"
            )));
        }
<# ix = 1; foreach (string deserializeLine in this.deserializeCode) { #>
        <#=deserializeLine#><#=ix == this.deserializeCode.Count ? ".map_err(DeserializationError::InvalidPayload)" : ""#>
<# ix++; } #>
    }
}

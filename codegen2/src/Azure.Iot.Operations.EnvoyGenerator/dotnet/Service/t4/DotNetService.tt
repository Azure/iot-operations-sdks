<#@ template language="C#" linePragmas="false" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Azure.Iot.Operations.CodeGeneration" #>
/* Code generated by Azure.Iot.Operations.ProtocolCompilerLib v<#=System.Reflection.Assembly.GetExecutingAssembly().GetName().Version#>; DO NOT EDIT. */

#nullable enable

namespace <#=this.projectName#>.<#=this.genNamespace.GetTypeName(TargetLanguage.CSharp)#>
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
<# if (this.actionSpecs.Any() || this.propSpecs.Any() || this.eventSpec.Any()) { #>
    using System.Threading;
<# } #>
    using System.Threading.Tasks;
    using Azure.Iot.Operations.Protocol.Models;
    using Azure.Iot.Operations.Protocol;
    using Azure.Iot.Operations.Protocol.RPC;
    using Azure.Iot.Operations.Protocol.Telemetry;
    using <#=this.projectName#>;

    [System.CodeDom.Compiler.GeneratedCode("Azure.Iot.Operations.ProtocolCompilerLib", "<#=System.Reflection.Assembly.GetExecutingAssembly().GetName().Version#>")]
    public static partial class <#=this.serviceName.GetTypeName(TargetLanguage.CSharp)#>
    {
<# if (this.generateServer) { #>
        public abstract partial class Service : IAsyncDisposable
        {
            private ApplicationContext applicationContext;
            private IMqttPubSubClient mqttClient;
<# foreach (var actionSpec in this.actionSpecs) { #>
            private readonly <#=actionSpec.Executor.GetTypeName(TargetLanguage.CSharp)#> <#=actionSpec.Executor.GetVariableName(TargetLanguage.CSharp)#>;
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
            private readonly <#=propSpec.Maintainer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.readResponderName.GetTypeName(TargetLanguage.CSharp)#> <#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "responder")#>;
<# if (propSpec.WriteReqSchema != null) { #>
            private readonly <#=propSpec.Maintainer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.writeResponderName.GetTypeName(TargetLanguage.CSharp)#> <#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "responder")#>;
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
            private readonly <#=telemEnvoyInfo.Sender.GetTypeName(TargetLanguage.CSharp)#> <#=telemEnvoyInfo.Sender.GetVariableName(TargetLanguage.CSharp)#>;
<# } #>

            /// <summary>
            /// Construct a new instance of this service.
            /// </summary>
            /// <param name="applicationContext">The shared context for your application.</param>
            /// <param name="mqttClient">The MQTT client to use.</param>
            /// <param name="topicTokenMap">
            /// The topic token replacement map to use for all operations by default. Generally, this will include the token values
            /// for topic tokens such as "modelId" which should be the same for the duration of this service's lifetime. Note that
            /// additional topic tokens can be specified per-telemetry message.
            /// </param>
            public Service(ApplicationContext applicationContext, IMqttPubSubClient mqttClient, Dictionary<string, string>? topicTokenMap = null)
            {
                this.applicationContext = applicationContext;
                this.mqttClient = mqttClient;

                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

<# foreach (var actionSpec in this.actionSpecs) { #>
                this.<#=actionSpec.Executor.GetVariableName(TargetLanguage.CSharp)#> = new <#=actionSpec.Executor.GetTypeName(TargetLanguage.CSharp)#>(applicationContext, mqttClient) { OnCommandReceived = <#=actionSpec.Name.GetMethodName(TargetLanguage.CSharp, "int")#> };
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "responder")#> = new <#=propSpec.Maintainer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.readResponderName.GetTypeName(TargetLanguage.CSharp)#>(applicationContext, mqttClient) { OnCommandReceived = <#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "int", prefix: "read")#> };
<# if (propSpec.WriteReqSchema != null) { #>
                this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "responder")#> = new <#=propSpec.Maintainer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.writeResponderName.GetTypeName(TargetLanguage.CSharp)#>(applicationContext, mqttClient) { OnCommandReceived = <#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "int", prefix: "write")#> };
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
                this.<#=telemEnvoyInfo.Sender.GetVariableName(TargetLanguage.CSharp)#> = new <#=telemEnvoyInfo.Sender.GetTypeName(TargetLanguage.CSharp)#>(applicationContext, mqttClient);
<# } #>

                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
<# foreach (var actionSpec in this.actionSpecs) { #>
                        this.<#=actionSpec.Executor.GetVariableName(TargetLanguage.CSharp)#>.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                        this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "responder")#>.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
<# if (propSpec.WriteReqSchema != null) { #>
                        this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "responder")#>.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
                        this.<#=telemEnvoyInfo.Sender.GetVariableName(TargetLanguage.CSharp)#>.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
<# } #>
                    }
                }

<# foreach (var actionSpec in this.actionSpecs) { #>
                this.<#=actionSpec.Executor.GetVariableName(TargetLanguage.CSharp)#>.TopicTokenMap.TryAdd("executorId", clientId);
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "responder")#>.TopicTokenMap.TryAdd("maintainerId", clientId);
<# if (propSpec.WriteReqSchema != null) { #>
                this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "responder")#>.TopicTokenMap.TryAdd("maintainerId", clientId);
<# } #>
<# } #>
            }
<# foreach (var actionSpec in this.actionSpecs) { #>

            public <#=actionSpec.Executor.GetTypeName(TargetLanguage.CSharp)#> <#=actionSpec.Executor.GetTypeName(TargetLanguage.CSharp)#> { get => this.<#=actionSpec.Executor.GetVariableName(TargetLanguage.CSharp)#>; }
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>

            public <#=propSpec.Maintainer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.readResponderName.GetTypeName(TargetLanguage.CSharp)#> <#=propSpec.Name.GetTypeName(TargetLanguage.CSharp, "read", "responder")#> { get => this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "responder")#>; }
<# if (propSpec.WriteReqSchema != null) { #>

            public <#=propSpec.Maintainer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.writeResponderName.GetTypeName(TargetLanguage.CSharp)#> <#=propSpec.Name.GetTypeName(TargetLanguage.CSharp, "write", "responder")#> { get => this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "responder")#>; }
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>

            public <#=telemEnvoyInfo.Sender.GetTypeName(TargetLanguage.CSharp)#> <#=telemEnvoyInfo.Sender.GetTypeName(TargetLanguage.CSharp)#> { get => this.<#=telemEnvoyInfo.Sender.GetVariableName(TargetLanguage.CSharp)#>; }
<# } #>
<# foreach (var actionSpec in this.actionSpecs) { #>

            public <#=this.defaultImpl ? "virtual" : "abstract"#> <#=this.ExtRespType(actionSpec)#> <#=actionSpec.Name.GetMethodName(TargetLanguage.CSharp, "async")#>(<#=this.ReqParam(actionSpec)#>CommandRequestMetadata requestMetadata, CancellationToken cancellationToken)<#=this.defaultImpl ? "" : ";"#>
<# if (this.defaultImpl) { #>
            {
                return <#=this.EmptyResp(actionSpec)#>;
            }
<# } #>
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>

            public abstract Task<ExtendedResponse<<#=propSpec.PropSchema.GetTypeName(TargetLanguage.CSharp)#>>> <#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "async", prefix: "read")#>(CommandRequestMetadata requestMetadata, CancellationToken cancellationToken);
<# if (propSpec.WriteReqSchema != null) { #>

            public abstract Task<CommandResponseMetadata?> <#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "async", prefix: "write")#>(<#=propSpec.WriteReqSchema.GetTypeName(TargetLanguage.CSharp)#> <#=propSpec.Name.GetVariableName(TargetLanguage.CSharp)#>, CommandRequestMetadata requestMetadata, CancellationToken cancellationToken);
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>

            /// <summary>
            /// Send telemetry.
            /// </summary>
            /// <param name="telemetry">The payload of the telemetry.</param>
            /// <param name="metadata">The metadata of the telemetry.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic token map provided in the constructor. If this map
            /// contains any keys that topic token map provided in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="qos">The quality of service to send the telemetry with.</param>
            /// <param name="telemetryTimeout">How long the telemetry message will be available on the broker for a receiver to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            public async Task <#=this.TelemMethodName(telemEnvoyInfo, "send", "async")#>(<#=telemEnvoyInfo.Schema.GetTypeName(TargetLanguage.CSharp)#> telemetry, OutgoingTelemetryMetadata metadata, Dictionary<string, string>? additionalTopicTokenMap = null, MqttQualityOfServiceLevel qos = MqttQualityOfServiceLevel.AtLeastOnce, TimeSpan? telemetryTimeout = null, CancellationToken cancellationToken = default)
            {
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }
                await this.<#=telemEnvoyInfo.Sender.GetVariableName(TargetLanguage.CSharp)#>.SendTelemetryAsync(telemetry, metadata, prefixedAdditionalTopicTokenMap, qos, telemetryTimeout, cancellationToken);
            }
<# } #>
<# if (this.actionSpecs.Any() || this.propSpecs.Any()) { #>

            /// <summary>
            /// Begin accepting command invocations for all command executors.
            /// </summary>
            /// <param name="preferredDispatchConcurrency">The dispatch concurrency count for the command response cache to use.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            public async Task StartAsync(int? preferredDispatchConcurrency = null, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before starting service.");
                }

                await Task.WhenAll(
<# foreach (var actionSpec in this.actionSpecs) { #>
                    this.<#=actionSpec.Executor.GetVariableName(TargetLanguage.CSharp)#>.StartAsync(preferredDispatchConcurrency, cancellationToken)<#=this.IsLast(actionSpec) ? ").ConfigureAwait(false);" : ","#>
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                    this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "responder")#>.StartAsync(preferredDispatchConcurrency, cancellationToken)<#=this.IsLast(propSpec) && propSpec.WriteReqSchema == null ? ").ConfigureAwait(false);" : ","#>
<# if (propSpec.WriteReqSchema != null) { #>
                    this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "responder")#>.StartAsync(preferredDispatchConcurrency, cancellationToken)<#=this.IsLast(propSpec) ? ").ConfigureAwait(false);" : ","#>
<# } #>
<# } #>
            }

            public async Task StopAsync(CancellationToken cancellationToken = default)
            {
                await Task.WhenAll(
<# foreach (var actionSpec in this.actionSpecs) { #>
                    this.<#=actionSpec.Executor.GetVariableName(TargetLanguage.CSharp)#>.StopAsync(cancellationToken)<#=this.IsLast(actionSpec) ? ").ConfigureAwait(false);" : ","#>
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                    this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "responder")#>.StopAsync(cancellationToken)<#=this.IsLast(propSpec) && propSpec.WriteReqSchema == null ? ").ConfigureAwait(false);" : ","#>
<# if (propSpec.WriteReqSchema != null) { #>
                    this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "responder")#>.StopAsync(cancellationToken)<#=this.IsLast(propSpec) ? ").ConfigureAwait(false);" : ","#>
<# } #>
<# } #>
            }
<# } #>
<# foreach (var actionSpec in this.actionSpecs) { #>

            private async Task<ExtendedResponse<<#=this.SchemaType(actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#>>> <#=actionSpec.Name.GetMethodName(TargetLanguage.CSharp, "int")#>(ExtendedRequest<<#=this.SchemaType(actionSpec.RequestSchema, actionSpec.SerializerEmptyType)#>> req, CancellationToken cancellationToken)
            {
<# if (actionSpec.ErrorResultName != null) { #>
                try
                {
                    <#=this.IntLValue(actionSpec)#>await this.<#=actionSpec.Name.GetMethodName(TargetLanguage.CSharp, "async")#>(<#=this.ReqArgs(actionSpec, "req")#>, cancellationToken);

                    return new ExtendedResponse<<#=this.SchemaType(actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#>>
                    {

                        Response = new <#=this.SchemaType(actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#>
                        {
<# foreach (CodeName normalResultName in actionSpec.NormalResultNames) { #>
                            <#=normalResultName.GetFieldName(TargetLanguage.CSharp)#> = extended.Response.<#=normalResultName.GetFieldName(TargetLanguage.CSharp)#>,
<# } #>
                        },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
                catch (<#=actionSpec.ErrorResultSchema.GetTypeName(TargetLanguage.CSharp, "exception")#> intEx)
                {
                    ExtendedResponse<<#=this.SchemaType(actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#>> extendedResponse = ExtendedResponse<<#=this.SchemaType(actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#>>.CreateFromResponse(new <#=this.SchemaType(actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#> { <#=actionSpec.ErrorResultName.GetFieldName(TargetLanguage.CSharp)#> = intEx.<#=actionSpec.ErrorResultSchema.GetFieldName(TargetLanguage.CSharp)#> });
<# if (actionSpec.ErrorCodeName != null) { #>

                    if (intEx.TryGetApplicationError(out <#=actionSpec.ErrorCodeSchema.GetTypeName(TargetLanguage.CSharp)#>? <#=actionSpec.ErrorCodeName.GetVariableName(TargetLanguage.CSharp)#>, out <#=this.GetInfoSchema(actionSpec.ErrorInfoSchema)#>? <#=this.GetInfoName(actionSpec.ErrorInfoName)#>))
                    {
                        extendedResponse = extendedResponse.WithApplicationError((<#=actionSpec.ErrorCodeSchema.GetTypeName(TargetLanguage.CSharp)#>)<#=actionSpec.ErrorCodeName.GetVariableName(TargetLanguage.CSharp)#>, <#=this.GetInfoName(actionSpec.ErrorInfoName)#>);
                    }

<# } #>
                    return extendedResponse;
                }
<# } else { #>
                <#=this.IntLValue(actionSpec)#>await this.<#=actionSpec.Name.GetMethodName(TargetLanguage.CSharp, "async")#>(<#=this.ReqArgs(actionSpec, "req")#>, cancellationToken);
                return new ExtendedResponse<<#=this.SchemaType(actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#>> { <#=this.IntRValue(actionSpec)#>};
<# } #>
            }
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>

            private async Task<ExtendedResponse<<#=propSpec.ReadRespSchema.GetTypeName(TargetLanguage.CSharp)#>>> <#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "int", prefix: "read")#>(ExtendedRequest<<#=propSpec.ReadSerializerEmptyType.GetTypeName(TargetLanguage.CSharp)#>> req, CancellationToken cancellationToken)
            {
<# if (propSpec.ReadErrorName != null) { #>
                try
                {
                    ExtendedResponse<<#=propSpec.PropSchema.GetTypeName(TargetLanguage.CSharp)#>> extended = await this.<#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "async", prefix: "read")#>(req.RequestMetadata!, cancellationToken);

                    return new ExtendedResponse<<#=propSpec.ReadRespSchema.GetTypeName(TargetLanguage.CSharp)#>>
                    {
                        Response = new <#=propSpec.ReadRespSchema.GetTypeName(TargetLanguage.CSharp)#> { <#=propSpec.PropValueName.GetFieldName(TargetLanguage.CSharp)#> = extended.Response<#=propSpec.IsAggregate ? "" : $".{propSpec.PropValueName.GetFieldName(TargetLanguage.CSharp)}"#> },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
                catch (<#=propSpec.ReadErrorSchema.GetTypeName(TargetLanguage.CSharp, "exception")#> intEx)
                {
                    ExtendedResponse<<#=this.SchemaType(propSpec.ReadRespSchema, propSpec.ReadSerializerEmptyType)#>> extendedResponse = ExtendedResponse<<#=this.SchemaType(propSpec.ReadRespSchema, propSpec.ReadSerializerEmptyType)#>>.CreateFromResponse(new <#=this.SchemaType(propSpec.ReadRespSchema, propSpec.ReadSerializerEmptyType)#> { <#=propSpec.ReadErrorName.GetFieldName(TargetLanguage.CSharp)#> = intEx.<#=propSpec.ReadErrorSchema.GetFieldName(TargetLanguage.CSharp)#> });
                    return extendedResponse;
                }
<# } else { #>
                return await this.<#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "async", prefix: "read")#>(req.RequestMetadata!, cancellationToken);
<# } #>
            }
<# if (propSpec.WriteReqSchema != null) { #>

            private async Task<ExtendedResponse<<#=(propSpec.WriteRespSchema ?? propSpec.WriteSerializerEmptyType).GetTypeName(TargetLanguage.CSharp)#>>> <#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "int", prefix: "write")#>(ExtendedRequest<<#=propSpec.WriteReqSchema.GetTypeName(TargetLanguage.CSharp)#>> req, CancellationToken cancellationToken)
            {
<# if (propSpec.WriteRespSchema != null) { #>
                try
                {
                    CommandResponseMetadata? respMetadata = await this.<#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "async", prefix: "write")#>(req.Request!, req.RequestMetadata!, cancellationToken);

                    return new ExtendedResponse<<#=propSpec.WriteRespSchema.GetTypeName(TargetLanguage.CSharp)#>>
                    {
                        Response = new <#=propSpec.WriteRespSchema.GetTypeName(TargetLanguage.CSharp)#>
                        {
                            <#=propSpec.WriteErrorName.GetFieldName(TargetLanguage.CSharp)#> = null,
                        },
                        ResponseMetadata = respMetadata,
                    };
                }
                catch (<#=propSpec.WriteErrorSchema.GetTypeName(TargetLanguage.CSharp, "exception")#> intEx)
                {
                    ExtendedResponse<<#=this.SchemaType(propSpec.WriteRespSchema, propSpec.WriteSerializerEmptyType)#>> extendedResponse = ExtendedResponse<<#=this.SchemaType(propSpec.WriteRespSchema, propSpec.WriteSerializerEmptyType)#>>.CreateFromResponse(new <#=this.SchemaType(propSpec.WriteRespSchema, propSpec.WriteSerializerEmptyType)#> { <#=propSpec.WriteErrorName.GetFieldName(TargetLanguage.CSharp)#> = intEx.<#=propSpec.WriteErrorSchema.GetFieldName(TargetLanguage.CSharp)#> });
                    return extendedResponse;
                }
<# } else { #>
                CommandResponseMetadata? respMetadata = await this.<#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "async", prefix: "write")#>(req.Request!, req.RequestMetadata!, cancellationToken);
                return new ExtendedResponse<<#=propSpec.WriteSerializerEmptyType.GetTypeName(TargetLanguage.CSharp)#>>
                {
                    Response = new <#=propSpec.WriteSerializerEmptyType.GetTypeName(TargetLanguage.CSharp)#>(),
                    ResponseMetadata = respMetadata,
                };
<# } #>
            }
<# } #>
<# } #>

            public async ValueTask DisposeAsync()
            {
<# foreach (var actionSpec in this.actionSpecs) { #>
                await this.<#=actionSpec.Executor.GetVariableName(TargetLanguage.CSharp)#>.DisposeAsync().ConfigureAwait(false);
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                await this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "responder")#>.DisposeAsync().ConfigureAwait(false);
<# if (propSpec.WriteReqSchema != null) { #>
                await this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "responder")#>.DisposeAsync().ConfigureAwait(false); 
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
                await this.<#=telemEnvoyInfo.Sender.GetVariableName(TargetLanguage.CSharp)#>.DisposeAsync().ConfigureAwait(false);
<# } #>
            }

            public async ValueTask DisposeAsync(bool disposing)
            {
<# foreach (var actionSpec in this.actionSpecs) { #>
                await this.<#=actionSpec.Executor.GetVariableName(TargetLanguage.CSharp)#>.DisposeAsync(disposing).ConfigureAwait(false);
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                await this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "responder")#>.DisposeAsync(disposing).ConfigureAwait(false);
<# if (propSpec.WriteReqSchema != null) { #>
                await this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "responder")#>.DisposeAsync(disposing).ConfigureAwait(false); 
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
                await this.<#=telemEnvoyInfo.Sender.GetVariableName(TargetLanguage.CSharp)#>.DisposeAsync(disposing).ConfigureAwait(false);
<# } #>
            }
        }
<# } #>
<# if (this.generateServer && this.generateClient) { #>

<# } #>
<# if (this.generateClient) { #>
        public abstract partial class Client<#=this.actionSpecs.Any() || this.propSpecs.Any() ? " : IAsyncDisposable" : ""#>
        {
            private ApplicationContext applicationContext;
            private IMqttPubSubClient mqttClient;
<# foreach (var actionSpec in this.actionSpecs) { #>
            private readonly <#=actionSpec.Invoker.GetTypeName(TargetLanguage.CSharp)#> <#=actionSpec.Invoker.GetVariableName(TargetLanguage.CSharp)#>;
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
            private readonly <#=propSpec.Consumer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.readRequesterName.GetTypeName(TargetLanguage.CSharp)#> <#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "requester")#>;
<# if (propSpec.WriteReqSchema != null) { #>
            private readonly <#=propSpec.Consumer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.writeRequesterName.GetTypeName(TargetLanguage.CSharp)#> <#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "requester")#>;
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
            private readonly <#=telemEnvoyInfo.Receiver.GetTypeName(TargetLanguage.CSharp)#> <#=telemEnvoyInfo.Receiver.GetVariableName(TargetLanguage.CSharp)#>;
<# } #>

            /// <summary>
            /// Construct a new instance of this client.
            /// </summary>
            /// <param name="applicationContext">The shared context for your application.</param>
            /// <param name="mqttClient">The MQTT client to use.</param>
            /// <param name="topicTokenMap">
            /// The topic token replacement map to use for all operations by default. Generally, this will include the token values
            /// for topic tokens such as "modelId" which should be the same for the duration of this client's lifetime.
            /// </param>
            public Client(ApplicationContext applicationContext, IMqttPubSubClient mqttClient, Dictionary<string, string>? topicTokenMap = null)
            {
                this.applicationContext = applicationContext;
                this.mqttClient = mqttClient;

<# foreach (var actionSpec in this.actionSpecs) { #>
                this.<#=actionSpec.Invoker.GetVariableName(TargetLanguage.CSharp)#> = new <#=actionSpec.Invoker.GetTypeName(TargetLanguage.CSharp)#>(applicationContext, mqttClient);
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "requester")#> = new <#=propSpec.Consumer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.readRequesterName.GetTypeName(TargetLanguage.CSharp)#>(applicationContext, mqttClient);
<# if (propSpec.WriteReqSchema != null) { #>
                this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "requester")#> = new <#=propSpec.Consumer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.writeRequesterName.GetTypeName(TargetLanguage.CSharp)#>(applicationContext, mqttClient);
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
                this.<#=telemEnvoyInfo.Receiver.GetVariableName(TargetLanguage.CSharp)#> = new <#=telemEnvoyInfo.Receiver.GetTypeName(TargetLanguage.CSharp)#>(applicationContext, mqttClient) { OnTelemetryReceived = this.<#=this.TelemMethodName(telemEnvoyInfo, "receive")#> };
<# } #>

                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
<# foreach (var actionSpec in this.actionSpecs) { #>
                        this.<#=actionSpec.Invoker.GetVariableName(TargetLanguage.CSharp)#>.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                        this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "requester")#>.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
<# if (propSpec.WriteReqSchema != null) { #>
                        this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "requester")#>.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
                        this.<#=telemEnvoyInfo.Receiver.GetVariableName(TargetLanguage.CSharp)#>.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
<# } #>
                    }
                }
            }
<# foreach (var actionSpec in this.actionSpecs) { #>

            public <#=actionSpec.Invoker.GetTypeName(TargetLanguage.CSharp)#> <#=actionSpec.Invoker.GetTypeName(TargetLanguage.CSharp)#> { get => this.<#=actionSpec.Invoker.GetVariableName(TargetLanguage.CSharp)#>; }
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>

            public <#=propSpec.Consumer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.readRequesterName.GetTypeName(TargetLanguage.CSharp)#> <#=propSpec.Name.GetTypeName(TargetLanguage.CSharp, "read", "requester")#> { get => this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "requester")#>; }
<# if (propSpec.WriteReqSchema != null) { #>

            public <#=propSpec.Consumer.GetTypeName(TargetLanguage.CSharp)#>.<#=this.writeRequesterName.GetTypeName(TargetLanguage.CSharp)#> <#=propSpec.Name.GetTypeName(TargetLanguage.CSharp, "write", "requester")#> { get => this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "requester")#>; }
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>

            public <#=telemEnvoyInfo.Receiver.GetTypeName(TargetLanguage.CSharp)#> <#=telemEnvoyInfo.Receiver.GetTypeName(TargetLanguage.CSharp)#> { get => this.<#=telemEnvoyInfo.Receiver.GetVariableName(TargetLanguage.CSharp)#>; }
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>

            public <#=this.defaultImpl ? "virtual" : "abstract"#> Task <#=this.TelemMethodName(telemEnvoyInfo, "receive")#>(string senderId, <#=telemEnvoyInfo.Schema.GetTypeName(TargetLanguage.CSharp)#> telemetry, IncomingTelemetryMetadata metadata)<#=this.defaultImpl ? "" : ";"#>
<# if (this.defaultImpl) { #>
            {
                return Task.CompletedTask;
            }
<# } #>
<# } #>
<# foreach (var actionSpec in this.actionSpecs) { #>

            /// <summary>
            /// Invoke a command.
            /// </summary>
<# if (actionSpec.DoesTargetExecutor) { #>
            /// <param name="executorId">The identifier of the executor targeted by this command request.</param>
<# } #>
<# if (actionSpec.RequestSchema != null) { #>
            /// <param name="request">The data for this command request.</param>
<# } #>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public <#=this.CallAsyncType(actionSpec)#> <#=actionSpec.Name.GetMethodName(TargetLanguage.CSharp, "async")#>(<#=this.ExecParam(actionSpec)#><#=this.ReqParam(actionSpec)#>CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;
<# if (actionSpec.DoesTargetExecutor) { #>
                prefixedAdditionalTopicTokenMap["executorId"] = executorId;
<# } #>

                return new <#=this.CallAsyncType(actionSpec)#>(this.<#=this.IntMethod(actionSpec)#>(<#=actionSpec.RequestSchema != null ? $"request" : actionSpec.SerializerEmptyType.GetAllocator(TargetLanguage.CSharp)#>, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>

            public <#=this.CallAsyncType(propSpec)#> <#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "async", prefix: "read")#>(<#=this.ReadMaintParam(propSpec)#>CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before requesting to read property.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["consumerClientId"] = clientId;
<# if (propSpec.DoesReadTargetMaintainer) { #>
                prefixedAdditionalTopicTokenMap["maintainerId"] = maintainerId;
<# } #>

                return new <#=this.CallAsyncType(propSpec)#>(this.<#=this.IntReadMethod(propSpec)#>(<#=propSpec.ReadSerializerEmptyType.GetAllocator(TargetLanguage.CSharp)#>, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }
<# if (propSpec.WriteReqSchema != null) { #>

            public RpcCallAsync<<#=propSpec.ReadSerializerEmptyType.GetTypeName(TargetLanguage.CSharp)#>> <#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "async", prefix: "write")#>(<#=this.WriteMaintParam(propSpec)#><#=propSpec.WriteReqSchema.GetTypeName(TargetLanguage.CSharp)#> request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before requesting to write property.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["consumerClientId"] = clientId;
<# if (propSpec.DoesWriteTargetMaintainer) { #>
                prefixedAdditionalTopicTokenMap["maintainerId"] = maintainerId;
<# } #>

                return new RpcCallAsync<<#=propSpec.WriteSerializerEmptyType.GetTypeName(TargetLanguage.CSharp)#>>(this.<#=this.IntWriteMethod(propSpec)#>(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }
<# } #>
<# } #>
<# if (this.eventSpec.Any()) { #>

            /// <summary>
            /// Begin accepting telemetry for all telemetry receivers.
            /// </summary>
            /// <param name="cancellationToken">Cancellation token.</param>
            public async Task StartAsync(CancellationToken cancellationToken = default)
            {
                await Task.WhenAll(
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
                    this.<#=telemEnvoyInfo.Receiver.GetVariableName(TargetLanguage.CSharp)#>.StartAsync(cancellationToken)<#=this.IsLast(telemEnvoyInfo) ? ").ConfigureAwait(false);" : ","#>
<# } #>
            }
<# } #>
<# if (this.eventSpec.Any()) { #>

            /// <summary>
            /// Stop accepting telemetry for all telemetry receivers.
            /// </summary>
            /// <param name="cancellationToken">Cancellation token.</param>
            public async Task StopAsync(CancellationToken cancellationToken = default)
            {
                await Task.WhenAll(
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
                    this.<#=telemEnvoyInfo.Receiver.GetVariableName(TargetLanguage.CSharp)#>.StopAsync(cancellationToken)<#=this.IsLast(telemEnvoyInfo) ? ").ConfigureAwait(false);" : ","#>
<# } #>
            }
<# } #>
<# foreach (var actionSpec in this.actionSpecs) { #>
<# if (actionSpec.ErrorResultName != null) { #>

            private async Task<ExtendedResponse<<#=this.SchemaType(actionSpec.NormalResultSchema ?? actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#>>> <#=actionSpec.Name.GetMethodName(TargetLanguage.CSharp, "int")#>(<#=this.SchemaType(actionSpec.RequestSchema, actionSpec.SerializerEmptyType)#> request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<<#=this.SchemaType(actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#>> extended = await this.<#=actionSpec.Invoker.GetVariableName(TargetLanguage.CSharp)#>.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);

                if (extended.Response.<#=actionSpec.ErrorResultName.GetFieldName(TargetLanguage.CSharp)#> != null)
                {
                    <#=actionSpec.ErrorResultSchema.GetTypeName(TargetLanguage.CSharp, "exception")#> <#=actionSpec.ErrorResultSchema.GetVariableName(TargetLanguage.CSharp, "exception")#> = new <#=actionSpec.ErrorResultSchema.GetTypeName(TargetLanguage.CSharp, "exception")#>(extended.Response.<#=actionSpec.ErrorResultName.GetFieldName(TargetLanguage.CSharp)#>);
<# if (actionSpec.ErrorCodeName != null) { #>

                    if (extended.TryGetApplicationError(out <#=actionSpec.ErrorCodeSchema.GetTypeName(TargetLanguage.CSharp)#>? <#=actionSpec.ErrorCodeName.GetVariableName(TargetLanguage.CSharp)#>, out <#=this.GetInfoSchema(actionSpec.ErrorInfoSchema)#>? <#=this.GetInfoName(actionSpec.ErrorInfoName)#>))
                    {
                        <#=actionSpec.ErrorResultSchema.GetVariableName(TargetLanguage.CSharp, "exception")#> = <#=actionSpec.ErrorResultSchema.GetVariableName(TargetLanguage.CSharp, "exception")#>.WithApplicationError((<#=actionSpec.ErrorCodeSchema.GetTypeName(TargetLanguage.CSharp)#>)<#=actionSpec.ErrorCodeName.GetVariableName(TargetLanguage.CSharp)#>, <#=this.GetInfoName(actionSpec.ErrorInfoName)#>);
                    }

<# } #>
                    throw <#=actionSpec.ErrorResultSchema.GetVariableName(TargetLanguage.CSharp, "exception")#>;
                }
                else
                {
                    return new ExtendedResponse<<#=this.SchemaType(actionSpec.NormalResultSchema ?? actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#>>
                    {
                        Response = new <#=this.SchemaType(actionSpec.NormalResultSchema ?? actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)#>
                        {
<# foreach (CodeName normalResultName in actionSpec.NormalResultNames) { #>
                            <#=normalResultName.GetFieldName(TargetLanguage.CSharp)#> = extended.Response.<#=normalResultName.GetFieldName(TargetLanguage.CSharp)#><#=actionSpec.NormalRequiredNames.Contains(normalResultName) ? ".Value()" : ""#>,
<# } #>
                        },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }
<# } #>
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
<# if (propSpec.ReadErrorName != null) { #>

            private async Task<ExtendedResponse<<#=this.SchemaType(propSpec.PropSchema, propSpec.ReadSerializerEmptyType)#>>> <#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "int", prefix: "read")#>(<#=propSpec.ReadSerializerEmptyType.GetTypeName(TargetLanguage.CSharp)#> request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<<#=this.SchemaType(propSpec.ReadRespSchema, propSpec.ReadSerializerEmptyType)#>> extended = await this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "requester")#>.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);

                if (extended.Response.<#=propSpec.ReadErrorName.GetFieldName(TargetLanguage.CSharp)#> != null)
                {
                    <#=propSpec.ReadErrorSchema.GetTypeName(TargetLanguage.CSharp, "exception")#> <#=propSpec.ReadErrorSchema.GetVariableName(TargetLanguage.CSharp, "exception")#> = new <#=propSpec.ReadErrorSchema.GetTypeName(TargetLanguage.CSharp, "exception")#>(extended.Response.<#=propSpec.ReadErrorName.GetFieldName(TargetLanguage.CSharp)#>);
                    throw <#=propSpec.ReadErrorSchema.GetVariableName(TargetLanguage.CSharp, "exception")#>;
                }
                else if (extended.Response.<#=propSpec.PropValueName.GetFieldName(TargetLanguage.CSharp)#> == null)
                {
                    throw new AkriMqttException("Property read response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<<#=this.SchemaType(propSpec.PropSchema, propSpec.ReadSerializerEmptyType)#>>
                    {
<# if (propSpec.IsAggregate) { #>
                        Response = extended.Response.<#=propSpec.PropValueName.GetFieldName(TargetLanguage.CSharp)#>,
<# } else { #>
                        Response = new <#=this.SchemaType(propSpec.PropSchema, propSpec.ReadSerializerEmptyType)#> { <#=propSpec.PropValueName.GetFieldName(TargetLanguage.CSharp)#> = extended.Response.<#=propSpec.PropValueName.GetFieldName(TargetLanguage.CSharp)#>.Value() },
<# } #>
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }
<# } #>
<# if (propSpec.WriteErrorName != null) { #>

            private async Task<ExtendedResponse<<#=propSpec.WriteSerializerEmptyType.GetTypeName(TargetLanguage.CSharp)#>>> <#=propSpec.Name.GetMethodName(TargetLanguage.CSharp, "int", prefix: "write")#>(<#=propSpec.WriteReqSchema.GetTypeName(TargetLanguage.CSharp)#> request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<<#=this.SchemaType(propSpec.WriteRespSchema, propSpec.WriteSerializerEmptyType)#>> extended = await this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "requester")#>.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);

                if (extended.Response.<#=propSpec.WriteErrorName.GetFieldName(TargetLanguage.CSharp)#> != null)
                {
                    <#=propSpec.WriteErrorSchema.GetTypeName(TargetLanguage.CSharp, "exception")#> <#=propSpec.WriteErrorSchema.GetVariableName(TargetLanguage.CSharp, "exception")#> = new <#=propSpec.WriteErrorSchema.GetTypeName(TargetLanguage.CSharp, "exception")#>(extended.Response.<#=propSpec.WriteErrorName.GetFieldName(TargetLanguage.CSharp)#>);
                    throw <#=propSpec.WriteErrorSchema.GetVariableName(TargetLanguage.CSharp, "exception")#>;
                }
                else
                {
                    return new ExtendedResponse<<#=propSpec.WriteSerializerEmptyType.GetTypeName(TargetLanguage.CSharp)#>>
                    {
                        Response = <#=propSpec.WriteSerializerEmptyType.GetAllocator(TargetLanguage.CSharp)#>,
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }
<# } #>
<# } #>

            public async ValueTask DisposeAsync()
            {
<# foreach (var actionSpec in this.actionSpecs) { #>
                await this.<#=actionSpec.Invoker.GetVariableName(TargetLanguage.CSharp)#>.DisposeAsync().ConfigureAwait(false);
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                await this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "requester")#>.DisposeAsync().ConfigureAwait(false);
<# if (propSpec.WriteReqSchema != null) { #>
                await this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "requester")#>.DisposeAsync().ConfigureAwait(false); 
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
                await this.<#=telemEnvoyInfo.Receiver.GetVariableName(TargetLanguage.CSharp)#>.DisposeAsync().ConfigureAwait(false);
<# } #>
            }

            public async ValueTask DisposeAsync(bool disposing)
            {
<# foreach (var actionSpec in this.actionSpecs) { #>
                await this.<#=actionSpec.Invoker.GetVariableName(TargetLanguage.CSharp)#>.DisposeAsync(disposing).ConfigureAwait(false);
<# } #>
<# foreach (var propSpec in this.propSpecs) { #>
                await this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "requester")#>.DisposeAsync(disposing).ConfigureAwait(false);
<# if (propSpec.WriteReqSchema != null) { #>
                await this.<#=propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "requester")#>.DisposeAsync(disposing).ConfigureAwait(false); 
<# } #>
<# } #>
<# foreach (var telemEnvoyInfo in this.eventSpec) { #>
                await this.<#=telemEnvoyInfo.Receiver.GetVariableName(TargetLanguage.CSharp)#>.DisposeAsync(disposing).ConfigureAwait(false);
<# } #>
            }
        }
<# } #>
    }
}
<#+
    private string IntLValue(ActionSpec actionSpec) => (actionSpec.ResponseSchema != null ? $"ExtendedResponse<{this.SchemaType(actionSpec.NormalResultSchema ?? actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)}> extended = " : $"CommandResponseMetadata? responseMetadata = ");

    private string IntRValue(ActionSpec actionSpec) => (actionSpec.ResponseSchema != null ? "Response = extended.Response, ResponseMetadata = extended.ResponseMetadata " : "ResponseMetadata = responseMetadata ");

    private string ExtRespType(ActionSpec actionSpec) => this.CondWrap(actionSpec.ResponseSchema != null ? $"ExtendedResponse<{this.SchemaType(actionSpec.NormalResultSchema ?? actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)}>" : "CommandResponseMetadata?");

    private string EmptyResp(ActionSpec actionSpec) => this.CondFrom(actionSpec.ResponseSchema != null ? $"new ExtendedResponse<{this.SchemaType(actionSpec.NormalResultSchema ?? actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)}> {{ Response = new {this.SchemaType(actionSpec.NormalResultSchema ?? actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)}() }}" : "(CommandResponseMetadata?)new CommandResponseMetadata()");

    private string CondWrap(string type) => $"Task<{type}>";

    private string CondFrom(string res) => $"Task.FromResult({res})";

    private string ReqParam(ActionSpec actionSpec) => actionSpec.RequestSchema != null ? $"{this.SchemaType(actionSpec.RequestSchema, actionSpec.SerializerEmptyType)} request, " : "";

    private string ReqArgs(ActionSpec actionSpec, string reqVar) => actionSpec.RequestSchema != null ? $"{reqVar}.Request!, {reqVar}.RequestMetadata!" : $"{reqVar}.RequestMetadata!";

    private string CallAsyncType(ActionSpec actionSpec) => $"RpcCallAsync<{this.SchemaType(actionSpec.NormalResultSchema ?? actionSpec.ResponseSchema, actionSpec.SerializerEmptyType)}>";

    private string CallAsyncType(PropertySpec propSpec) => $"RpcCallAsync<{this.SchemaType(propSpec.PropSchema, propSpec.ReadSerializerEmptyType)}>";

    private string IntMethod(ActionSpec actionSpec) => actionSpec.ErrorResultName != null ? actionSpec.Name.GetMethodName(TargetLanguage.CSharp, "int") : $"{actionSpec.Invoker.GetVariableName(TargetLanguage.CSharp)}.InvokeCommandAsync";

    private string IntReadMethod(PropertySpec propSpec) => propSpec.ReadErrorName != null ? propSpec.Name.GetMethodName(TargetLanguage.CSharp, "int", prefix: "read") : $"{propSpec.Name.GetVariableName(TargetLanguage.CSharp, "read", "requester")}.InvokeCommandAsync";

    private string IntWriteMethod(PropertySpec propSpec) => propSpec.WriteErrorName != null ? propSpec.Name.GetMethodName(TargetLanguage.CSharp, "int", prefix: "write") : $"{propSpec.Name.GetVariableName(TargetLanguage.CSharp, "write", "requester")}.InvokeCommandAsync";

    private string SchemaType(ITypeName schema, EmptyTypeName emptyType) => schema?.GetTypeName(TargetLanguage.CSharp) ?? emptyType.GetTypeName(TargetLanguage.CSharp);

    private string ExecParam(ActionSpec actionSpec) => actionSpec.DoesTargetExecutor ? "string executorId, " : "";

    private string ReadMaintParam(PropertySpec propSpec) => propSpec.DoesReadTargetMaintainer ? "string maintainerId, " : "";

    private string WriteMaintParam(PropertySpec propSpec) => propSpec.DoesWriteTargetMaintainer ? "string maintainerId, " : "";

    private bool IsLast(ActionSpec actionSpec) => actionSpec.Name.AsGiven == this.actionSpecs.Last().Name.AsGiven && !this.propSpecs.Any();

    private bool IsLast(PropertySpec propSpec) => propSpec.Name == null || propSpec.Name.AsGiven == this.propSpecs.Last().Name.AsGiven;

    private bool IsLast(EventSpec telemEnvoyInfo) => telemEnvoyInfo.Name.AsGiven == this.eventSpec.Last().Name.AsGiven;

    private string TelemMethodName(EventSpec telemEnvoyInfo, string prefix, string suffix = null) => (new CodeName()).GetMethodName(TargetLanguage.CSharp, "telemetry", suffix, prefix: prefix);

    private string GetInfoName(CodeName infoName) => infoName?.GetVariableName(TargetLanguage.CSharp) ?? "errorPayload";

    private string GetInfoSchema(CodeName infoSchema) => infoSchema?.GetTypeName(TargetLanguage.CSharp) ?? "string";
#>
